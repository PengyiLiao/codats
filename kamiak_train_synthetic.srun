#!/bin/bash
#SBATCH --job-name=train_synthetic
#SBATCH --output=slurm_logs/train_%A_%a.out
#SBATCH --error=slurm_logs/train_%A_%a.err
#SBATCH --cpus-per-task=3
#SBATCH --gres=gpu:1
#SBATCH --partition=cook,free_gpu,cahnrs_gpu,kamiak
#SBATCH --time=1-00:00:00
#SBATCH --mem=20G
#SBATCH --array=0-2078

# My computer
#gpumem=4500
# SBATCH --partition=cook
# SBATCH --cpus-per-task=4
# SBATCH --gres=gpu:0
# SBATCH --mem=10G
# Kamiak
gpumem=0
# SBATCH --partition=cook,free_gpu,cahnrs_gpu,kamiak
# SBATCH --cpus-per-task=3
# SBATCH --gres=gpu:1
# SBATCH --mem=20G

. kamiak_config.sh

# Errors
handle_terminate() { echo "Exiting"; exit 1; }
handle_error() { echo "Error occured -- exiting"; exit 1; }
trap "handle_terminate" SIGTERM SIGINT

# Get suffix, i.e. files stored in kamiak-{models,logs}-suffix
suffix=$1; shift
[[ -z $suffix ]] && { echo "no suffix specified"; handle_error; }

# Adapt in both directions, then do upper bound
methods=("vrada" "rdann" "cycada" "random" "dann" "deepjdot" "dann_grl" "none" "upper")  # slowest to fastest for shortest time
debugnums=(1 2 3)
sources=(
    "freqshift_phase_a"  "freqshift_phase_a"  "freqshift_phase_a"  "freqshift_phase_a"  "freqshift_phase_a"  "freqshift_phase_a"  "freqshift_phase_a"  "freqshift_phase_a"  "freqshift_phase_a"  "freqshift_phase_a"  "freqshift_phase_a"
    "freqscale_phase_a"  "freqscale_phase_a"  "freqscale_phase_a"  "freqscale_phase_a"  "freqscale_phase_a"  "freqscale_phase_a"  "freqscale_phase_a"  "freqscale_phase_a"  "freqscale_phase_a"  "freqscale_phase_a"  "freqscale_phase_a"
    "rotate2_phase_a"    "rotate2_phase_a"    "rotate2_phase_a"    "rotate2_phase_a"    "rotate2_phase_a"    "rotate2_phase_a"    "rotate2_phase_a"    "rotate2_phase_a"    "rotate2_phase_a"    "rotate2_phase_a"    "rotate2_phase_a"
    "freqscaleshift_phase_a"  "freqscaleshift_phase_a"  "freqscaleshift_phase_a"  "freqscaleshift_phase_a"  "freqscaleshift_phase_a"  "freqscaleshift_phase_a"  "freqscaleshift_phase_a"  "freqscaleshift_phase_a"  "freqscaleshift_phase_a"  "freqscaleshift_phase_a"  "freqscaleshift_phase_a"
    "freqshiftrotate_phase_a"  "freqshiftrotate_phase_a"  "freqshiftrotate_phase_a"  "freqshiftrotate_phase_a"  "freqshiftrotate_phase_a"  "freqshiftrotate_phase_a"  "freqshiftrotate_phase_a"  "freqshiftrotate_phase_a"  "freqshiftrotate_phase_a"  "freqshiftrotate_phase_a"  "freqshiftrotate_phase_a"
    "freqscalerotate_phase_a"  "freqscalerotate_phase_a"  "freqscalerotate_phase_a"  "freqscalerotate_phase_a"  "freqscalerotate_phase_a"  "freqscalerotate_phase_a"  "freqscalerotate_phase_a"  "freqscalerotate_phase_a"  "freqscalerotate_phase_a"  "freqscalerotate_phase_a"  "freqscalerotate_phase_a"
    "freqscaleshiftrotate_phase_a"  "freqscaleshiftrotate_phase_a"  "freqscaleshiftrotate_phase_a"  "freqscaleshiftrotate_phase_a"  "freqscaleshiftrotate_phase_a"  "freqscaleshiftrotate_phase_a"  "freqscaleshiftrotate_phase_a"  "freqscaleshiftrotate_phase_a"  "freqscaleshiftrotate_phase_a"  "freqscaleshiftrotate_phase_a"  "freqscaleshiftrotate_phase_a"
)
targets=(
    "freqshift_phase_b0" "freqshift_phase_b1" "freqshift_phase_b2" "freqshift_phase_b3" "freqshift_phase_b4" "freqshift_phase_b5" "freqshift_phase_b6" "freqshift_phase_b7" "freqshift_phase_b8" "freqshift_phase_b9" "freqshift_phase_b10"
    "freqscale_phase_b0" "freqscale_phase_b1" "freqscale_phase_b2" "freqscale_phase_b3" "freqscale_phase_b4" "freqscale_phase_b5" "freqscale_phase_b6" "freqscale_phase_b7" "freqscale_phase_b8" "freqscale_phase_b9" "freqscale_phase_b10"
    "rotate2_phase_b0"   "rotate2_phase_b1"   "rotate2_phase_b2"   "rotate2_phase_b3"   "rotate2_phase_b4"   "rotate2_phase_b5"   "rotate2_phase_b6"   "rotate2_phase_b7"   "rotate2_phase_b8"   "rotate2_phase_b9"   "rotate2_phase_b10"
    "freqscaleshift_phase_b0" "freqscaleshift_phase_b1" "freqscaleshift_phase_b2" "freqscaleshift_phase_b3" "freqscaleshift_phase_b4" "freqscaleshift_phase_b5" "freqscaleshift_phase_b6" "freqscaleshift_phase_b7" "freqscaleshift_phase_b8" "freqscaleshift_phase_b9" "freqscaleshift_phase_b10"
    "freqshiftrotate_phase_b0" "freqshiftrotate_phase_b1" "freqshiftrotate_phase_b2" "freqshiftrotate_phase_b3" "freqshiftrotate_phase_b4" "freqshiftrotate_phase_b5" "freqshiftrotate_phase_b6" "freqshiftrotate_phase_b7" "freqshiftrotate_phase_b8" "freqshiftrotate_phase_b9" "freqshiftrotate_phase_b10"
    "freqscalerotate_phase_b0" "freqscalerotate_phase_b1" "freqscalerotate_phase_b2" "freqscalerotate_phase_b3" "freqscalerotate_phase_b4" "freqscalerotate_phase_b5" "freqscalerotate_phase_b6" "freqscalerotate_phase_b7" "freqscalerotate_phase_b8" "freqscalerotate_phase_b9" "freqscalerotate_phase_b10"
    "freqscaleshiftrotate_phase_b0" "freqscaleshiftrotate_phase_b1" "freqscaleshiftrotate_phase_b2" "freqscaleshiftrotate_phase_b3" "freqscaleshiftrotate_phase_b4" "freqscaleshiftrotate_phase_b5" "freqscaleshiftrotate_phase_b6" "freqscaleshiftrotate_phase_b7" "freqscaleshiftrotate_phase_b8" "freqscaleshiftrotate_phase_b9" "freqscaleshiftrotate_phase_b10"
)

# Make sure we're using the right number
correct_min=0
correct_max=$(( ${#methods[@]} * ${#debugnums[@]} * ${#sources[@]} - 1))
[[ ${#sources[@]} == ${#targets[@]} ]] || \
    { echo "source/target sizes should match"; handle_error; }
[[ $SLURM_ARRAY_TASK_MIN == $correct_min ]] || \
    { echo "array min should be $correct_min"; handle_error; }
[[ $SLURM_ARRAY_TASK_MAX == $correct_max ]] || \
    { echo "array max should be $correct_max"; handle_error; }

# Indexing: https://stackoverflow.com/a/34363187
index=$SLURM_ARRAY_TASK_ID
index1max=${#sources[@]}
index2max=${#debugnums[@]}
index3=$((index / (index1max * index2max)))
index=$((index - index3 * index1max * index2max))
index2=$((index / index1max))
index1=$((index % index1max))

method="${methods[$index3]}"
debugnum="${debugnums[$index2]}"
source="${sources[$index1]}"
target="${targets[$index1]}"

# Upper bound is actually "none" but without a target domain and with other args
additional_args=()
if [[ $method == "upper" ]]; then
    method="none"
    source="$target"
    target=""
    additional_args+=("--best_source" "--notrain_on_source_valid")
fi

# Training / model options
steps=30000
lr=0.0001
model=fcn

if [[ $method == "vrada" || $method == "rdann" ]]; then
    model="$method"
    batch=64
elif [[ $method == "random" ]]; then
    batch=50
    additional_args+=("--log_val_steps=100")
else
    batch=250
fi

# Pretraining - VRADA requires its custom reconstruction loss
if [[ $method == "vrada" || $method == "random" ]]; then
    pretraining=0
else
    pretraining=1000
fi

echo "$suffix #$SLURM_ARRAY_TASK_ID"
echo "Method: $method"
echo "DebugNum: $debugnum"
echo "Other args: $@"
echo "$source --> $target"

cd "$remotedir"
export OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK
module load cuda/10.0.130 cudnn/7.5.1.10_cuda10.0 python3/3.6.5
python3 main.py \
    --logdir="$logFolder-$suffix" --modeldir="$modelFolder-$suffix" \
    --model="$model" --steps="$steps" --train_batch=$batch --pretrain_steps=$pretraining --lr="$lr" \
    --method="$method" --source="$source" --target="$target" --debugnum="$debugnum" \
    --gpumem="$gpumem" "${additional_args[@]}" "$@" || handle_error
